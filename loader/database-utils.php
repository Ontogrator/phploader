
<?php

include_once( 'config.php' );

require_once 'MDB2.php';

class DatabaseUtils
{
  private $statement_cache;
  private $verbosity ;

  function __construct()
  {
    $this->verbosity = 0;

    $this->statement_cache = array();
  }
  
  
  public function empty_table( $database_connection, $table_name )
  {
    $result =& $database_connection->query( 'DELETE FROM ' . $table_name );
    
    if ( PEAR::isError( $result ) ) { die( $result->getMessage() ); }
    
    echo $result->db->last_query . "\n";
  }



  private function trim_to_width( $value, $width )
  {
    if( strlen( $value ) < $width )
      {
	return $value;
      }
    else
      {
	return substr( $value, 0, $width );
      }
  }


  public function store_entry( $database_connection, $data_source_name, $data_source_wrapper, $parts )
  {
    global $data_source_infos;


    if( isset( $parts[ 'id' ] ) == false )
      {
	die( "Missing 'id' - unable to load \n" );
      }

    $columns = $data_source_infos[ $data_source_name ][ "columns" ];

    // i'm unable to work out why the following prepared statment version of the code doesn't work - so i use a direct version instead

    /*

    $key = 'store:' . $data_source_name;
    
    
    if( isset( $this->statement_cache[ $key ] ) )
      {
	$prepared_statement = $this->statement_cache[ $key ];
      }
    else
      {
	$sql = 'INSERT INTO ' . $data_source_name . '_entry ( id, url';

	foreach( $columns as $name => $width )
	  {
	    $sql .= ', ' . $name;
	  }

	$sql .=  ' ) VALUES ( ?, ?';

	foreach( $columns as $name => $width )
	  {
	    $sql .= ', ?';
	  }
	
	$sql .= ' )';

	echo $sql . "\n";

	$prepared_statement = $database_connection->prepare( $sql );

	if ( PEAR::isError( $prepared_statement ) )  
	  {
	    die( $prepared_statement->getMessage() . "\n" );
	  }

	$this->statement_cache[ $key ] = $prepared_statement ;
      }
    
    // the id and url are already known...

    $data = array();

    $data[] = $parts[ 'id' ];

    $data[] = $data_source_wrapper->get_url( $parts );

    // the other values are in the 'parts' hash

    foreach( $columns as $name => $width )
      {
	if( isset( $parts[ $name ] ) )
	  {
	    $data[] = $parts[ $name ];
	  }
	else
	  {
	    $data[] = '';
	  }

	//echo $name . ' => ' . $parts[ $name ] . "\n";
      }

    // et voila...

    foreach( $data as $thing )
      {
	echo $thing . "\n";
      }

    $result = $prepared_statement->execute( array( $data ) );
    */


    $sql = 'INSERT INTO ' . $data_source_name . '_entry ( id, url';
    foreach( $columns as $name => $width )
      {
	$sql .= ', ';
	$sql .= $name;
      }
    
    $sql .=  ' ) VALUES ( ';
    
    $sql .= $database_connection->quote( $parts[ 'id' ] );
    $sql .= ',';
    $sql .= $database_connection->quote( $data_source_wrapper->get_url( $parts ) );

    
    foreach( $columns as $name => $width )
      {
	$sql .= ',';
	
	if( isset( $parts[ $name ] ) )
	  {
	    $trimmed_value = $this->trim_to_width( trim( $parts[ $name ] ), $width );
	    
	    $sql .= $database_connection->quote( $trimmed_value, "text", true );
	  }
	else
	  {
	    $sql .= '""';
	  }
      }

    $sql .= ' )';

    // echo $sql . "\n";

    $result = & $database_connection->query( $sql );

    if ( PEAR::isError( $result ) )  
      {
	// var_dump( $result );

	die( 'store_entry.execute: ' . $result->getMessage() . "\n" );
      }


    //echo $database_connection->last_query . "\n";

    return true;
  }


  public function remove_terminizer_hits( $database_connection, $data_source_name )
  {
    global $ontology_infos;

    foreach( $ontology_infos as $short_name => $ontology_info )
      {
	$result =& $database_connection->query( 'DELETE FROM ' . $data_source_name . '_' .  $short_name . '_hit' );
	
	if ( PEAR::isError( $result ) ) { die( $result->getMessage() ); }
    
	echo $result->db->last_query . "\n";
      }
  }


  public function remove_taxonomizer_hits( $database_connection, $data_source_name )
  {
    $result = $database_connection->query( 'DELETE FROM ' . $data_source_name . '_TAX_hit' );
    
    if ( PEAR::isError( $result ) )  
      {
	die( $result->getMessage() );
      }
    
    echo $result->db->last_query . "\n";
  }



  // $hits should be in the format that is generated by "Terminizer::terminize()"
  //
  public function store_terminizer_hits( $database_connection, $data_source_name, $id, $hits )
  {
    global $ontology_infos;
    
    foreach( $ontology_infos as $short_name => $ontology_info )
      {
	//echo "store_hits(): checking " . $data_source_name . " / " . $short_name . " for " . $id . "...\n";

	if( isset( $hits[ $short_name ] ) )
	  {
	    $key = 'hit:' . $data_source_name . ':' . $short_name;
	    
	    if( isset( $this->statement_cache[ $key ] ) )
	      {
		$prepared_statement = $this->statement_cache[ $key ];
	      }
	    else
	      {
		$prepared_statement = $database_connection->prepare( 'INSERT INTO ' . $data_source_name . '_' .  $short_name . '_hit ( id, name ) VALUES ( ?,? )' );

		if ( PEAR::isError( $prepared_statement ) )  
		  {
		    die( $prepared_statement->getMessage() . "\n" );
		  }
		
		$this->statement_cache[ $key ] = $prepared_statement ;
	      }
	    
	    foreach( $hits[ $short_name ] as $hit )
	      {
		//echo "(" . $id . ":" .  $hit . ")\n";
		
		$result = $prepared_statement->execute( array( $id, $hit ) );
		
		if ( PEAR::isError( $result ) )  
		  {
		    // var_dump( $result );
		    
		    die( 'store_terminizer_hits.execute: ' . $result->getMessage() . "\n" );
		  }

		//echo 'store_hits: ' . $id . " " . $hit . " ... OK\n";
	      }
	  }
      }
  }

  // $hits should be in the format that is generated by "Taxonomizer::taxonomize()"
  //
  public function store_taxonomizer_hits( $database_connection, $data_source_name, $id, $taxonomizer_hits )
  {
    //echo "sth\n";

    if( count( $taxonomizer_hits ) > 0 )
      {
	$key = "insert_tax_hit:" . $data_source_name;
	
	if( isset( $this->statement_cache[  $key ] ) )
	  {
	    $stmt = $this->statement_cache[ $key ];
	  }
	else
	  {
	    $stmt = $database_connection->prepare( 'INSERT INTO ' . $data_source_name . '_TAX_hit ( id, name ) VALUES ( ?, ? )' );
	    
	    if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
	    
	    $this->statement_cache[ $key ] = $stmt;
	  }
 	
	foreach( $taxonomizer_hits as $taxonomy_chain )
	  {
	    $index_of_leaf = count( $taxonomy_chain ) - 1;
	    
	    $parent_term = null;
	    
	    for( $index = 0; $index <= $index_of_leaf; $index++ )
	      {
		$term = $taxonomy_chain[ $index ];
		
		// if it's not been seen before, store the term (and it's parental relationship) 
		//
		$this->possibly_insert_tax_term( $database_connection, $term, $parent_term  );
		
		// store the hit for this term against the data item
		//

		$result = $stmt->execute( array( $id, $term ) );
		
		if ( PEAR::isError( $result ) )  
		  {
		    // var_dump( $result );
		    
		    die( 'store_terminizer_hits.execute: ' . $result->getMessage() . "\n" );
		  }

		//echo '  => taxHit of ' . $term . ' for ' . $id . "\n";

		$parent_term = $term;
	      }
	  }
      }

    //echo "sthOK\n";

  }
  
  public function possibly_insert_tax_term( $database_connection, $term, $parent_term  )
  {
    if( $this->verbosity > 1 )
      {
	echo "pitt: [" . $term . "] [" . $parent_term . "]\n";
      }

    // does it already exist?

    if( $this->get_tax_term( $database_connection, $term ) == null )
      {
	
	if( isset( $this->statement_cache[ "insert_tax_term" ] ) )
	  {
	    $stmt = $this->statement_cache[ "insert_tax_term" ];
	  }
	else
	  {
	    $stmt = $database_connection->prepare( 'INSERT INTO TAX_term ( name, parent_count, child_count ) VALUES ( ?, ?, ? )' );
	    
	    if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
	    
	    $this->statement_cache[ "insert_tax_term" ] = $stmt;
	  }
	
	$parent_count = ( $parent_term == null ) ? 0 : 1;
	$child_count = 0;

	if( $this->verbosity > 1 )
	  {
	    echo "pitt inserting: " . $term . " [cc=0,pc=" . $parent_count . "]\n";
	  }
	
	$stmt->execute( array( $term, $parent_count, $child_count ) );

	//echo "pittOK[t]\n";
      }
    else
      {
	// term already exists...do nothing (::TODO:: should really be checking parent_count)
 
	if( $this->verbosity > 1 )
	  {
	    echo "pitt: " . $term . " EXISTS ALREADY\n";
	  }
      }

    if( $parent_term != null )
      {
	// verify that the parent term has already been loaded (and load it if neccessary)

	$this->possibly_insert_tax_term( $database_connection, $parent_term, null );


	// does the relationship already exist?

	$existing_parents = $this->get_tax_parents( $database_connection, $term );

	if( array_search( $parent_term, $existing_parents ) === false )
	  {
	    if( isset( $this->statement_cache[ 'insert_tax_parent' ] ) )
	      {
		$stmt = $this->statement_cache[ 'insert_tax_parent' ];
	      }
	    else
	      {
		$stmt = $database_connection->prepare( 'INSERT INTO TAX_parent ( name, parent ) VALUES ( ?, ? )' );

		if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
		
		$this->statement_cache[ 'insert_tax_parent' ] = $stmt;
	      }
	    
	    if( $this->verbosity > 1 )
	      {
		echo "pitt t2p: " . $term . ' => ' . $parent_term . "\n";
	      }

	    $stmt->execute( array( $term, $parent_term ) );


	    // and increment the child count for this parent

	    if( isset( $this->statement_cache[ 'increment_child_count' ] ) )
	      {
		$stmt = $this->statement_cache[ 'increment_child_count' ];
	      }
	    else
	      {
		$stmt = $database_connection->prepare( 'UPDATE TAX_term SET child_count=1 WHERE name=?' );

		if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
		
		$this->statement_cache[ 'increment_child_count' ] = $stmt;
	      }
	    
	    if( $this->verbosity > 1 )
	      {
		echo "increment cc for: " . $parent_term . "\n";
	      }

	    $stmt->execute( array( $parent_term ) );


	    // and the parent_count count for the child

	    if( isset( $this->statement_cache[ 'increment_parent_count' ] ) )
	      {
		$stmt = $this->statement_cache[ 'increment_parent_count' ];
	      }
	    else
	      {
		$stmt = $database_connection->prepare( 'UPDATE TAX_term SET parent_count=1 WHERE name=?' );

		if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
		
		$this->statement_cache[ 'increment_parent_count' ] = $stmt;
	      }
	    
	    if( $this->verbosity > 1 )
	      {
		echo "increment pc for: " . $parent_term . "\n";
	      }

	    $stmt->execute( array( $term ) );

	    
	    //echo "pittOK\n";
	  }
	else
	  {
	    if( $this->verbosity > 1 )
	      {
		echo "pitt t2p: " . $term . ' => ' . $parent_term . " EXISTS ALREADY\n";
	      }
	  }
      }
  }

  private function get_tax_term( $database_connection, $term )
  {
    //echo "gtt\n";

    if( isset( $this->statement_cache[ "find_tax_term" ] ) )
      {
	$stmt = $this->statement_cache[ "find_tax_term" ];
      }
    else
      {
	$stmt = $database_connection->prepare( 'SELECT parent_count FROM TAX_term WHERE name=?' );
	
	if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
	
	$this->statement_cache[ "find_tax_term" ] = $stmt;
      }
    
    $results = $stmt->execute( array( $term ) );
    
    //echo "gttOK\n";

    if ( $row = $results->fetchRow() )
      {
	return true;
      }
    else
      {
	return false;
      }
  }

  private function get_tax_parents( $database_connection, $term )
  {
    //echo "gtp\n";

    if( isset( $this->statement_cache[ "find_tax_parents" ] ) )
      {
	$stmt = $this->statement_cache[ "find_tax_parents" ];
      }
    else
      {
	$stmt = $database_connection->prepare( 'SELECT parent FROM TAX_parent WHERE name=?' );
	
	if ( PEAR::isError( $stmt ) )  { die( $stmt->getMessage() . "\n" );  }
	
	$this->statement_cache[ "find_tax_parents" ] = $stmt;
      }
    
    $results = $stmt->execute( array( $term ) );
    
    $parents = array();

    while ( $row = $results->fetchRow() )
      {
	$parents[] = $row[ 0 ];
      }

    //echo "gtpOK\n";

    return $parents;
  }

}

?>